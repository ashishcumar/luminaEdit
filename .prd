PRD: "LuminaEdit" – Browser-Based Video Editor1. Project OverviewA high-performance, client-side video editor that allows users to trim, concatenate, and overlay effects on video files without a backend.Target User: Content creators needing quick, private edits.Key Value: Zero server costs, 100% privacy (data never leaves the browser).2. Core Functional RequirementsFeatureDescriptionLocal IngestUsers upload videos/audio via browser File API.Non-Destructive EditingTrimming/splitting doesn't change the source file, only the "metadata" of the clip.Multi-Track TimelineLayers for Video, Audio, and Text Overlays.Real-Time PreviewA seekable player that reflects timeline changes instantly.In-Browser ExportRendering the final sequence into a downloadable .mp4.3. Technical Architecture & ConstraintsCompute: FFmpeg.wasm (WebAssembly).Concurrency: Web Workers (to prevent Main Thread blocking).Memory: Max 2GB (Browser WASM limit). Must use "Memory Management" strategies.Storage: IndexedDB (for persistence of large video blobs).Step-by-Step Build GuidePhase 1: The "Sandbox" (Infrastructure)Objective: Establish the communication bridge between JS and the WASM binary.Configure Headers: Set up Vite with Cross-Origin-Opener-Policy: same-origin and Cross-Origin-Embedder-Policy: require-corp.The Singleton Pattern: Create an FFmpegManager class or hook. You only want one instance of FFmpeg running. Loading the 20MB-30MB WASM core multiple times will crash the tab.The Logger: Implement a callback to capture FFmpeg's stdout. This is your only way to debug why a video might be failing to process.Phase 2: The "Vault" (Data Persistence)Objective: Handle large files without refreshing the page and losing progress.IndexedDB Integration: When a user selects a file, store the File object in IndexedDB using Dexie.js.URL Management: Create "Object URLs" (URL.createObjectURL(blob)) for the <video> elements to preview files without loading them into JS memory.Cleanup: Implement a "Project Clear" function to revoke URLs and clear IndexedDB to prevent browser bloat.Phase 3: The "Engine" (Processing Logic)Objective: Perform the first "Tricky" task—The Trim.VFS Mounting: Write a utility that reads a file from IndexedDB and writes it to FFmpeg's Virtual File System (ffmpeg.writeFile).Command Execution: Run the trim command:ffmpeg -ss [start] -to [end] -i input.mp4 -c copy output.mp4Why -c copy? This performs a "Stream Copy," which is instant because it doesn't re-encode the video.The Extraction: Read the result from the VFS and convert it back to a Blob for the user to download.Phase 4: The "Timeline" (UI Engineering)Objective: Build the most complex UI component.The Time-to-Pixel Mapper: Create a constant (e.g., PX_PER_SEC = 50). Every clip's width in the UI is calculated as duration \* PX_PER_SEC.Scrubbing Engine: Use a requestAnimationFrame loop. As the user drags the playhead, update the currentTime of all video elements in the background to keep them in sync.The Virtual List: If the timeline gets long, only render the clips currently visible in the viewport to maintain 60fps.Phase 5: The "Filter Complex" (Advanced Rendering)Objective: Concatenate multiple clips into one file.Concat Logic: You cannot just "add" files together. You must generate a concat text file inside the FFmpeg VFS that lists all clip segments.The Progress Bar: FFmpeg.wasm emits a progress event with a ratio (0 to 1). Map this to a high-quality progress bar in your UI.Re-encoding: To add text overlays or transitions, you must switch from -c copy to re-encoding (e.g., -c:v libx264). Warning: This is CPU intensive and slow in WASM.
